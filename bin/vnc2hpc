#!/bin/bash
#
# vnc2hpc is a script that automates establishing vncclient>server connections to LANL HPC systems

# Basic VNC2HPC information
AUTHOR_EMAIL="jgreen@lanl.gov"
CONTACT="vnc2hpc@lanl.gov"
REPO="git@git.lanl.gov:hpcsoft/vnc2hpc.git"
README="https://git.lanl.gov/hpcsoft/vnc2hpc/-/blob/${VERSION}/README.md"

# Timestamp string for logs
MYDATE=$(date +%m-%d-%y"-"%H.%M.%S)

# SSH Control Master Socket
SSH_SOCKET="~/.ssh/connections/%C"

# Feature updates signified by even numbers
# Bugfix updates signified by odd numbers
VERSION="0.0.5"
REMOTE_INSTALL_PATH="/usr/projects/hpcsoft/vnc2hpc/${VERSION}"

# Window managers supported:
WMS=( "berry" "icewm" "fvwm" "mwm" "openbox" "xfwm4" )

usage () {
    message -m "${0//*\//} v${VERSION}

          usage: ${0//*\//}
                            [-m|--machine <machine>]				(required)
                            [-c|--client <vncclient>]				(required)
			    [-u|--user <hpcuserid>] 				(optional) Default: \$USER on localhost 
                            [-v|--debug]					(optional)
	                    [-d|--display <display>]				(optional)
			    [-k|--keep]						(optional)
			    [-r|--reconnect]					(optional)
			    [-w|--wm <icewm|berry|fvwm|mwm|xfwm4|openbox>]	(optional) Default: [-w mwm] (Motif Window Manager)
                            [-g|--geometry <int>x<int>]                 	(optional) Default: xdpyinfo |grep dimensions
                            [-P|--pixeldepth <int>]                     	(optional) Default: 24 - others: 8, 15, 16
                            [-s|--source /path/to/source.tar.gz]                (optional) Only Required for systems with no backend where client has no internet
                            [-j|--job <jobid>]					(optional)
			    [-h|--help]

          Questions?        <${CONTACT}>
          Need Help?        ${README}
"
}

#######################################
# Identify the Network for $MACHINE
# Globals:
#   MACHINE
# Arguments:
#   None
# Outputs:
#   Writes $loc_network to stdout
#######################################
check_network () {
    local loc_network
    case "${MACHINE}" in
        *loginy*|*fey*)			loc_network="YELLOW"    	;;
        *darwin*)			loc_network="DARWIN"		;;
        ic*|fi*|cy*|tr*|vm*)   		loc_network="RED"           	;;
        wtrw*)                 		loc_network="INVALID"       	;;
	gr*|ba*|cp-login*|ko*|sn*)	loc_network="TURQUOISE"     	;;
        *)				loc_network="UNKNOWN"		;;
    esac
    echo "${loc_network}"
}

#######################################
# Connect to JOBID
# Globals:
#   JOBID
# Arguments:
#   None
# Outputs:
# ?????
#######################################
connect_job () {
    echo "DO SOMETHING"   
}

#######################################
# Submit Batch Job
# Globals:
#   JOBID
# Arguments:
#   None
# Outputs:
# ?????
#######################################
slurm_job_submit() {
    while getopts "A:Q:R:T:C:P:N:" opt; do
        case $opt in
            A)  local loc_account="-A ${OPTARG}"		;;
            Q)  local loc_qos="--qos=${OPTARG}"			;;
            R)  local loc_reservation="--reservation=${OPTARG}"	;;
            T)  local loc_walltime="-t ${OPTARG}"		;;
            C)  local loc_contstraint="-c ${OPTARG}"		;;
            P)  local loc_partition="-p ${OPTARG}"		;;
            N)  local loc_numnodes="-n ${OPTARG}"		;;
            *)  echo "UNKNOWN OPTION"				;;
        esac
    done
    job_submit_cmd="salloc --x11=none --no-shell ${loc_numnodes} ${loc_partition} ${loc_constraint} ${loc_walltime} ${loc_reservation} ${loc_qos} ${loc_account}"
    inform "Submitting interactive job:" "$(echo ${job_submit_cmd})"
    JOBID=$( ${job_submit_cmd} )
    if echo ${JOBID} |grep -qi error ; then
        die "Salloc failed: ${JOBID}"
    else
        JOBID=$( echo $JOBID | grep -i "salloc: Granted job allocation" | awk '{print $5}')
        while ! job_running ${JOBID} ; do
           sleep 2
        done
    fi
}

#######################################
# Cancel JOBID
# Globals:
#   JOBID
# Arguments:
#   None
# Outputs:
# ?????
#######################################
job_cancel() {
  scancel $1 &>/dev/null
}

#######################################
# Check JOBID for Failure
# Globals:
#   JOBID
# Arguments:
#   None
# Outputs:
# ?????
#######################################
job_id_fail() {
  squeue -j $1 |grep -q 'slurm_load_jobs error: Invalid job id specified' &>/dev/null
  return $?
}

#######################################
# Check JOBID for COMPLETE
# Globals:
#   JOBID
# Arguments:
#   None
# Outputs:
# ?????
#######################################
job_completed() {
  sacct -j $1 | grep -q COMPLETED
}

#######################################
# Check JOBID for CANCEL
# Globals:
#   JOBID
# Arguments:
#   None
# Outputs:
# ?????
#######################################
job_cancelled() {
  sacct -j $1 | grep "$1 " | grep -q CANCELLED
}

#######################################
# Check JOBID for RUNNING
# Globals:
#   JOBID
# Arguments:
#   None
# Outputs:
# ?????
#######################################
job_running() {
  squeue -j $1 -o %T | grep RUNNING &> /dev/null
}

#######################################
# Check JOBID for FAIL
# Globals:
#   JOBID
# Arguments:
#   None
# Outputs:
# ?????
#######################################
job_failed() {
  #sacct -j $1 | grep FAILED &> /dev/null
  sacct -j $1 | grep "$1 " | grep FAILED &> /dev/null
}

#######################################
# Get maxppn for JOBID
# Globals:
#   JOBID
# Arguments:
#   None
# Outputs:
# ?????
#######################################
maxppn() {
  MAX_PPN=$(sinfo -h -o '%c'|sed s'/+//g')
  if [[ -z $MAX_PPN ]] ; then
    MAX_PPN=1
  fi
  echo $MAX_PPN
}

#######################################
# Get HEADNODE for JOBID
# Globals:
#   JOBID
# Arguments:
#   None
# Outputs:
# ?????
#######################################
headnode() {
  SLURM_NODELIST=`squeue -j $1 -o %N | awk '$0 !~ /^NODELIST/'`
  HEADNODE=`scontrol show hostnames "$SLURM_NODELIST" | head -n 1`
  echo $HEADNODE
}

#######################################
# Tunnel to Jobid
# Globals:
#   JOBID
# Arguments:
#   None
# Outputs:
# ?????
#######################################
tunneler() {
  sleep 10
  SLURM_NODELIST=`squeue -j $1 -o %N | awk '$0 !~ /^NODELIST/'`
  reporter "\$SLURM_NODELIST=$SLURM_NODELIST"
  R0HOST=`scontrol show hostnames "$SLURM_NODELIST" | head -n 1`
  reporter "Establishing SSH port tunnel to rank 0 node $R0HOST"
  # Sometimes outputs a TCP_NODE OVERLAY ERROR. Don't know why or how to fix, but it still sets up the tunnel
  ssh -T -NnR ${PV_SERVER_PORT}:localhost:${PV_SERVER_PORT} $R0HOST >>${DEBUGOUT} 2>>${DEBUGOUTERR} &
  TUN_PID=$!
  return $TUN_PID
}

#######################################
# Ensure $MACHINE resolves
# Globals:
#   MACHINE
#   NETWORK
#   GATEWAY_SSH
#   NO_GATEWAY_SSH
# Arguments:
#   None
# Outputs:
#   Writes $loc_machine to stdout
#######################################
check_machine () {
    local loc_machine
    local loc_machines
    local loc_machine_index
    if [[ "${MACHINE}"x != x ]] ; then
        if ! [[ "$MACHINE" =~ [0-9] ]] && ! [[ "${MACHINE}" =~ cp ]] && ! [[ "${MACHINE}" =~ th ]]  ; then
            IGNORE="false"
            case "${NETWORK}" in
                YELLOW)    netpart="128.165" ;;
                DARWIN)    netpart="192.168" ;;
                TURQUOISE) netpart="204.121" ;;
                RED)       netpart="10.160"  ;;
                UNKNOWN)   IGNORE="true"     ;;
            esac
            if [[ "${IGNORE}" != "true" ]] ; then
                loc_machines=( $( ${GATEWAY_SSH} ${NO_GATEWAY_SSH} \
                    "awk -v pat=\"^${netpart//\./\\\.}.*${MACHINE//-*}-fe*.*gov\" '\$0~pat{print \$2}' /etc/hosts" 2>&- ) )
                if [[ ${#loc_machines[@]} -gt 0 ]] ; then
                    loc_machine_index=$(( $RANDOM % ${#loc_machines[@]} ))
                    loc_machine="${loc_machines[$loc_machine_index]}"
                else
                # try to access "${MACHINE}1" before failing
                    loc_machine="${MACHINE}1"
                fi
            fi
        elif [[ "${MACHINE}" =~ wtrw ]] ; then
            loc_machine="INVALID"
        else
            loc_machine="${MACHINE}"
        fi 
    else
        loc_machine="invalid"
    fi
    echo "$loc_machine"
}

#######################################
# Check vncserver on remote
# Globals:
#   GATEWAY_SSH
#   NO_GATEWAY_SSH
# Arguments:
#   None
# Outputs:
#   Writes "/path/to/vncserver" to stdout
#######################################
check_vncserver () {
    local loc_vncserver_path
    loc_vncserver_path=$( ${GATEWAY_SSH} ${NO_GATEWAY_SSH} \
        "which vncserver || find /opt/ -name \"vncserver\" -executable" 2>/dev/null)
    echo "$loc_vncserver_path"
}

#######################################
# Check remote SHELL
# Globals:
#   GATEWAY_SSH
#   NO_GATEWAY_SSH
# Arguments:
#   None
# Outputs:
#   Writes "SHELL" to stdout
######################################
check_remote_shell () {
    local loc_remote_shell
    loc_remote_shell=$( ${GATEWAY_SSH}${NO_GATEWAY_SSH} \
        "echo \$SHELL")
    echo "${loc_remote_shell}"
}

#######################################
# Setup ssh options for control master
# Globals:
#   SSH_SOCKET
# Arguments:
#   type (master, command, vncpasswd)
# Outputs:
#   Writes $loc_ssh_opts to stdout
#######################################
setup_ssh_opts () {
    # first glance, -x is easily abstracted to the common settings, but that prevents scp from working
    mkdir -p ~/.ssh/connections
    local loc_ssh_opts=""
    loc_ssh_opts+="-o LogLevel=QUIET"
    loc_ssh_opts+=" -o GSSAPIDelegateCredentials=yes"
    loc_ssh_opts+=" -o StrictHostKeyChecking=no"
    loc_ssh_opts+=" -o ControlPath=${SSH_SOCKET}"
    case "$1" in
        master)
            loc_ssh_opts+=" -x"
            loc_ssh_opts+=" -M"
            loc_ssh_opts+=" -N"
            loc_ssh_opts+=" -f"
            loc_ssh_opts+=" -o ControlPersist=yes"
        ;;
        command)
            loc_ssh_opts+=" -x"
            loc_ssh_opts+=" -tt"
            loc_ssh_opts+=" -N"
            loc_ssh_opts+=" -f"
        ;;
        vncpasswd)
            loc_ssh_opts+=" -x"
        ;;
        *)
            loc_ssh_opts+=""
        ;;
    esac 
    echo "$loc_ssh_opts"
}

#######################################
# Setup port/host string for tunnels
# Globals:
#   MACHINE
#   MACHUSER
#   DISPLAY
# Arguments:
#   None
# Outputs:
#   Writes $TUNNELHOST to stdout
#######################################
setup_tunnel_host () {
        echo "-L $(( 5900+${DISPLAY} )):localhost:$(( 5900+${DISPLAY} ))"
}

#######################################
# Ssh command
# Globals:
#   MACHUSER
#   MACHINE
# Arguments:
#   None
# Outputs:
#   Writes ssh cmd to stdout
#######################################
setup_nogateway_ssh () {
    echo "ssh $(setup_ssh_opts command) ${MACHUSER}@${MACHINE}"
}

#######################################
# Ssh command
# Globals:
#   MACHUSER
#   MACHINE
# Arguments:
#   None
# Outputs:
#   Writes ssh cmd to stdout
#######################################
setup_nogateway_ssh_control_master () {
    echo "ssh $(setup_ssh_opts master) ${MACHUSER}@${MACHINE}"
}

#######################################
# Ssh command
# Globals:
#   MACHUSER
#   MACHINE
# Arguments:
#   None
# Outputs:
#   Writes ssh cmd to stdout
#######################################
setup_nogateway_vncpasswd () {
    echo "ssh $(setup_ssh_opts vncpasswd) ${MACHUSER}@${MACHINE}"
}

#######################################
# Ssh command
# Globals:
#   SSH_SCP_OPTS
#   MACHUSER
#   MACHINE
# Arguments:
#   FILE
#   DEST
# Outputs:
#   Writes scp cmd to stdout
#######################################
setup_nogateway_scp () {
    local loc_file="${1}"
    local loc_dest="${2}"
    echo "scp ${SSH_SCP_OPTS} ${loc_file} ${MACHUSER}@${MACHINE}:${loc_dest}"
}

#######################################
# Ssh command check control master
# Globals:
#   MACHUSER
#   MACHINE
# Arguments:
#   None
# Outputs:
#   Writes ssh cmd to stdout
#######################################
check_nogateway_control_master_connection () {
    local loc_control_check="ssh -O check $(setup_ssh_opts command) ${MACHUSER}@${MACHINE}"
    echo "${loc_control_check}"
}

#######################################
# Ssh command kill control master
# Globals:
#   MACHUSER
#   MACHINE
# Arguments:
#   None
# Outputs:
#   Writes ssh cmd to stdout
#######################################
kill_nogateway_control_master_connection () {
    local loc_control_kill="ssh -O exit $(setup_ssh_opts command) ${MACHUSER}@${MACHINE}"
    echo "${loc_control_kill}"
}

#######################################
# Ssh command via wtrw
# Globals:
#   MACHUSER
#   MACHINE
# Arguments:
#   GATEWAY
# Outputs:
#   Writes ssh via wtrw to stdout
#######################################
setup_gateway_ssh () {
    local loc_gateway="$1"
    echo "ssh $(setup_ssh_opts command) ${MACHUSER}@${loc_gateway} ssh ${MACHUSER}@${MACHINE} "
}

#######################################
# Ssh command
# Globals:
#   MACHUSER
#   MACHINE
# Arguments:
#   None
# Outputs:
#   Writes ssh cmd to stdout
#######################################
setup_gateway_ssh_control_master () {
    local loc_gateway="$1"
    echo "ssh $(setup_ssh_opts master) ${MACHUSER}@${loc_gateway} ssh ${MACHUSER}@${MACHINE} "
}

#######################################
# Ssh command via wtrw
# Globals:
#   MACHUSER
#   MACHINE
# Arguments:
#   GATEWAY
# Outputs:
#   Writes ssh via wtrw to stdout
#######################################
setup_gateway_vncpasswd () {
    local loc_gateway="$1"
    local loc_opts="$2"
    echo "ssh $(setup_ssh_opts vncpasswd) ${MACHUSER}@${loc_gateway} ssh ${MACHUSER}@${MACHINE} "
}

#######################################
# Scp command via wtrw
# Globals:
#   SSH_SCP_OPTS
#   MACHUSER
#   MACHINE
# Arguments:
#   GATEWAY
#   FILE
#   DEST
# Outputs:
#   Writes scp via wtrw to stdout
#######################################
setup_gateway_scp () {
    local loc_gateway="$1"
    local loc_file="$2"
    local loc_dest="$3"
    echo "scp ${SSH_SCP_OPTS} ${loc_file} ${MACHUSER}@${loc_gateway}:${MACHINE}:${loc_dest}"
}
#######################################
# Ssh command check gateway control master
# Globals:
#   MACHUSER
#   MACHINE
# Arguments:
#   GATEWAY
# Outputs:
#   Writes ssh cmd to stdout
#######################################
check_gateway_control_master_connection () {
    local loc_gateway="$1"
    local loc_control_check="ssh -O check $(setup_ssh_opts command) ${MACHUSER}@${loc_gateway} ssh ${MACHUSER}@${MACHINE}"
    echo "${loc_control_check}"
}

#######################################
# Ssh command kill gateway control master
# Globals:
#   MACHUSER
#   MACHINE
# Arguments:
#   GATEWAY
# Outputs:
#   Writes ssh cmd to stdout
#######################################
kill_gateway_control_master_connection () {
    local loc_gateway="$1"
    local loc_control_kill="ssh -O exit $(setup_ssh_opts command) ${MACHUSER}@${loc_gateway} ssh ${MACHUSER}@${MACHINE}"
    echo "${loc_control_kill}"
}

#######################################
# Tunnel to host
# Globals:
#   DISPLAY
#   MACHUSER
#   MACHINE
#   TUNNEL_HOST
# Arguments:
#   None
# Outputs:
#   Writes ssh tunnel cmd to stdout
#######################################
setup_nogateway_tunnel () {
    echo "ssh $(setup_ssh_opts command) ${TUNNEL_HOST} ${MACHUSER}@${MACHINE}"
}

#######################################
# Tunnel to host via gateway
# Globals:
#   DISPLAY
#   MACHUSER
#   MACHINE
#   TUNNEL_HOST
# Arguments:
#   GATEWAY
# Outputs:
#   Writes ssh tunnel cmd to stdout
#######################################
setup_gateway_tunnel () {
    local loc_gateway="$1"
    echo "ssh $(setup_ssh_opts command) ${TUNNEL_HOST} ${MACHUSER}@${loc_gateway} ssh -tt ${TUNNEL_HOST} ${MACHUSER}@${MACHINE}"
}

#######################################
# Colorize output
# Globals:
#   None
# Arguments:
#   opt
#   $[1-4]
# Outputs:
#   colorizes message output based on flag
#######################################
message () {
    local color
    local OPTIND
    local opt
    while getopts "crgymn" opt; do
        case $opt in
            c)  color=$(tput setaf 6) ;;
            r)  color=$(tput setaf 1) ;;
	    g)  color=$(tput setaf 2) ;;
	    y)  color=$(tput setaf 3) ;;
	    m)  color=$(tput setaf 5) ;;
            *)  color=$(tput sgr0)    ;;
        esac
    done
    shift $(($OPTIND -1))
    printf "${color}%-10s %-50s %-50s %-50s\n" "$1" "$2" "$3" "$4"
    tput sgr0
}

#######################################
# Warn if something's amiss
# Globals:
#   None
# Arguments:
#   $[1-3]
# Outputs:
#   yellow printf output
#######################################
warning () {
    message -y "NOTE" "$1" "$2" "$3"
}

#######################################
# Gracefully exit on error
# Globals:
#   tunnel_pid
# Arguments:
#   $[1-3]
# Outputs:
#   red printf output
#######################################
die () {
    remotelog
    if kill -0 ${tunnel_pid} &>/dev/null ; then
        kill ${tunnel_pid} &>/dev/null
    fi
    $(${CONTROL_KILL})
    message -r "ERROR" "$1" "$2" "$3" >&2
    exit 2
}

#######################################
# Informative messages to user
# Globals:
#   None
# Arguments:
#   $[1-3]
# Outputs:
#   green printf output
#######################################
inform () {
    message -g "INFO" "$1" "$2" "$3"
}

#######################################
# Informative messages to user
# Globals:
#   None
# Arguments:
#   $[1-3]
# Outputs:
#   cyan printf output
#######################################
debug () {
    if [[ "${DEBUG}"x != x ]] ; then
        message -c "DEBUG" "$1" "$2" "$3"
    fi
}

#######################################
# Establish ControlMaster ssh connection
# Globals:
#   GATEWAY_SSH
#   NO_GATEWAY_SSH
# Arguments:
#   None
# Outputs:
#   control_master_ssh
#######################################
control_master_connection () {
    if [[ "${NETWORK}" =~ TURQUOISE ]] ; then
        local local_gateway="wtrw1.lanl.gov"
        local local_gateway_ssh=$(setup_gateway_ssh_control_master ${local_gateway})
    else
        local local_nogateway_ssh=$(setup_nogateway_ssh_control_master)
    fi
    local local_control_master_ssh="${local_gateway_ssh} ${local_nogateway_ssh}"
    echo "${local_control_master_ssh}"
}

#######################################
# Checks/sets vncpasswd interactively
# Globals:
#   GATEWAY_SSH
#   NO_GATEWAY_SSH
#   MACHUSER
#   MACHINE
# Arguments:
#   None
# Outputs:
#   None
#######################################
check_vncpasswd () {
    # need a $HOME/.vnc directory if the first use
    if ! $( ${GATEWAY_VNCPASSWD} ${NO_GATEWAY_VNCPASSWD} "[ -d \$HOME/.vnc ]" 2>&- ); then
        ${GATEWAY_VNCPASSWD} ${NO_GATEWAY_VNCPASSWD} "mkdir -p \$HOME/.vnc && chmod -Rf 0700 \$HOME/.vnc" 2>&-
    fi
    # test whether the vncpasswd file exists but is empty
    if ! $( ${GATEWAY_VNCPASSWD}${NO_GATEWAY_VNCPASSWD} "[ -s  \$HOME/.vnc/passwd ] || exit 1" ); then
        # ensure user is forewarned of potential exposure of passwd with xtrace
        if echo ${SHELLOPTS} | grep xtrace &>/dev/null ; then
            DISABLE_XTRACE="set +x"
            ENABLE_XTRACE="set -x"
        fi
        ${DISABLE_XTRACE}

        inform "VNC passwd not available or is of zero size on ${MACHINE} for $MACHUSER"
        inform "Do you want to setup a password now? [Y/N]"
        read PWREPLY

        case $PWREPLY in
            Y*|y*)
                inform "Enter your password (at least six characters long, up to eight)"
                read -s VNCPW
                inform "Reenter your password to confirm"
                read -s REVNCPW
                if [[ "${VNCPW}" == "${REVNCPW}" ]] ; then
                    inform "SETTING VNCPASSWD" "${MACHINE} for $MACHUSER"
                    eval '${GATEWAY_VNCPASSWD}${NO_GATEWAY_VNCPASSWD} /bin/bash <<EOF
echo "${VNCPW}" | /usr/bin/vncpasswd -f > \$HOME/.vnc/passwd && chmod 0600 \$HOME/.vnc/passwd
EOF'
                else
                    die "FIRST AND SECOND PASSWORDS DIDN'T MATCH"
                fi
                if ! ${GATEWAY_VNCPASSWD}${NO_GATEWAY_VNCPASSWD} "ls -al \$HOME/.vnc/passwd" &>/dev/null; then
                    die "SETTING VNCPASSWD FAILED!"
                fi 
                perms=$(${GATEWAY_VNCPASSWD}${NO_GATEWAY_VNCPASSWD} "ls -al \$HOME/.vnc/passwd")
                debug "CHECKING PERMS ON PASSWD FILE:" "$perms"
            ;;
            N*|n*)
                die "YOU MUST LOGIN TO ${MACHINE} AND SETUP A VNC PASSWORD TO PROCEED"
            ;;
            *)
                die "A password to use your vncserver on ${MACHINE} is required!"
            ;;
        esac
        ${ENABLE_XTRACE}
    fi
}

#######################################
# Command to kill the vncserver
# Globals:
#   GATEWAY_SSH
#   NO_GATEWAY_SSH
#   MACHUSER
#   MACHINE
# Arguments:
#   DISPLAY
# Outputs:
#   echos stdout from vncserver
#######################################
kill_vnc () {
    local loc_display=$1
    kill_vnc_response=$(${GATEWAY_SSH} ${NO_GATEWAY_SSH} ${VNCSERVER_PATH} -kill :${loc_display} 2>&1)
    # strange characters in stdout via wtrw filtered in the substitution below
    echo "${kill_vnc_response%$'\r'}"
}

#######################################
# Command to get all users Xvnc instances on remote
# Globals:
#   GATEWAY_SSH
#   NO_GATEWAY_SSH
#   MACHUSER
#   MACHINE
# Arguments:
#   None
# Outputs:
#   ${loc_vnc_cons[@]}
#######################################
get_vnc_connections () {
    for pt in $( ${GATEWAY_SSH} ${NO_GATEWAY_SSH} "ps ax| grep -E \"*/Xvnc :([0-9]+)\" \
                                                   | awk '{ gsub(\":\",\"\",\$6) } {print \$6}'") ; do
       local loc_vnc_cons=( $(printf "%s " "${pt%$'\r'}") "${loc_vnc_cons[@]}" )
    done
    echo "${loc_vnc_cons[@]}"
}

#######################################
# Command to get Users Vncserver list
# Globals:
#   GATEWAY_SSH
#   NO_GATEWAY_SSH
#   MACHINE
# Arguments:
#   None
# Outputs:
#   ${VNCSERVERS_LIST[@]}
#######################################
list_displays () {
    local loc_vncservers_list=( $(${GATEWAY_SSH} ${NO_GATEWAY_SSH} "${VNCSERVER_PATH} -list|egrep -v 'DISPLAY|T*VNC|^$' \
                                                          | awk '{ gsub(\":\",\"\",\$1); print \$1}'") )
    for item in ${loc_vncservers_list[@]} ; do
        loc_vncservers_list=( $(printf "%s " "${item%$'\r'}") "${loc_vncservers_list[@]}" )
    done
    echo "${loc_vncservers_list[@]}"
}

#######################################
# File tests ${CLIENT} for viability
# Globals:
#   CLIENT 
# Arguments:
#   None
# Outputs:
#   None
#######################################
client_check () {
    ( [ ! -d "${CLIENT}" ] && [ -x "${CLIENT}" ] ) || [ -x "$(which ${CLIENT})" ] || exit 1
}

#######################################
# File tests ${WINDOWMANAGER} for viability
# Globals:
#   WINDOWMANAGER
#   WMS
# Arguments:
#   None
# Outputs:
#   None
#######################################
wm_check () {
    if [[ ! "${WMS[@]}" =~ $WINDOWMANAGER ]] ; then
        return 2
    fi
}

#######################################
# Parses ${CLIENT} and version string
# Globals:
#   CLIENT
# Arguments:
#   None
# Outputs:
#   Client/Version
#######################################
client_version () {
    "${CLIENT}" -help 2>&1 | head -n 2 | awk '/./ {print $1$2"-"$3}' |head -n 1
}

#######################################
# Checks REMOTE_INSTALL_PATH
# Globals:
#   REMOTE_INSTALL_PATH
#   GATEWAY_SSH
#   NO_GATEWAY_SSH
#   MACHINE
# Arguments:
#   None
# Outputs:
#   BOOL (True|False)
#######################################
check_remote_install_path () {
    ${GATEWAY_SSH} ${NO_GATEWAY_SSH} "[ -d ${REMOTE_INSTALL_PATH} ]"
}

#######################################
# Gets OS info on localhost
# Globals:
#   None
# Arguments:
#   None
# Outputs:
#   OS String
#######################################
clientOS () {
    uname -a | awk '{print $2"-"$1}'
}

#######################################
# Remote ssh to capture server log file
# Globals:
#   GATEWAY_SSH
#   NO_GATEWAY_SSH
#   MACHINE
#   DISPLAY
#   LOGDIR
#   SERVER_LOG_FILE
# Arguments:
#   None
# Outputs:
#   None
#######################################
remotelog () {
    if [[ -n ${GATEWAY_SSH} ]] || [[ -n ${NO_GATEWAY_SSH} ]] ; then 
       ${GATEWAY_SSH} ${NO_GATEWAY_SSH} "cat \${HOME}/.vnc/${MACHINE//\.*/}*${DISPLAY#0}.log" >>${LOGDIR}/${SERVER_LOG_FILE} &>/dev/null
    fi 
}

#######################################
# Parse positional parameters passed to script
echo "${@}" # REMOVE
for arg in "$@"; do
    shift
    case "$arg" in
        *-cl*nt)	set -- "$@" "-c"   ;;
        *-debug)	set -- "$@" "-v"   ;;
        *-help)		set -- "$@" "-h"   ;;
        *-keep)		set -- "$@" "-k"   ;;
        *-machine)	set -- "$@" "-m"   ;;
        *-display)	set -- "$@" "-d"   ;;
        *-reconnect)	set -- "$@" "-r"   ;;
        *-user)		set -- "$@" "-u"   ;;
        *-wm*)		set -- "$@" "-w"   ;;
        *-geo*)		set -- "$@" "-g"   ;;
        *-depth*)	set -- "$@" "-P"   ;;
        *-source)	set -- "$@" "-s"   ;;
        *-jobid)	set -- "$@" "-j"   ;;
        *)		set -- "$@" "$arg" ;;
    esac
done

OPTIND=1

while getopts "bc:m:P:vu:w:g:d:hrks:-" opt ; do
    case "${opt}" in
        b)  BACKDOOR=true                                                                          			;;
        v)  DEBUG=true                                                                             			;;
        d)  DISPLAY="$OPTARG" ; debug "RECEIVED REQUEST TO CONNECT TO:" "${MACHINE} AT DISPLAY $DISPLAY"		;;
        m)  MACHINE="$OPTARG" ; debug "RECEIVED REQUEST TO CONNECT TO:" "${MACHINE}"               			;;
        c)  CLIENT=${OPTARG//\\/} && CLIENT=${CLIENT//\~/$HOME}                                    			;;
        k)  KEEP_VNC_SERVER_ACTIVE=true                                                            			;;
        r)  RECONNECT=true && KEEP_VNC_SERVER_ACTIVE=true                                          			;;
        h)  usage && exit 0                                                                        			;;
        u)  MACHUSER="${OPTARG}"                                                                   			;;
        w)  WINDOWMANAGER="${OPTARG}"                                                              			;;
        g)  GEOMETRY="${OPTARG}"                                                                   			;;
        P)  PIXELDEPTH="${OPTARG}"                                                                 			;;
        s)  SOURCE="${OPTARG}"                                                                     			;;
        j)  JOBID="${OPTARG}"												;;
        -)                                                                                         			;;
    esac
done

#######################################
# Inform vnc2hpc version used
inform "VNC2HPC VERSION:" "${VERSION}" 

# ensure display is set if arg is passed, and is number
[[ "${DISPLAY}" =~ ^[0-9]+$ ]] || die "DISPLAY isn't a number, or is unset" "DISPLAY=$DISPLAY"

# Check out the vncclient
if [[ "${CLIENT}x" == x ]] ; then usage; die "A PATH TO A VNC CLIENT MUST BE SUPPLIED TO ${0/\*/}!" ; fi
if ! $(client_check 2>&-) ; then die "$CLIENT" "FAILED BASIC TESTS" "RECHECK YOUR PATH TO VNCVIEWER" ; fi
CLIENT_VERSION=$(client_version)
inform "VNC CLIENT INFO:" "$CLIENT_VERSION"

# uname output on local host
CLIENTOS=$(clientOS)
inform "LOCALHOST OS INFO:" "$CLIENTOS"

# ensure MACHUSER is overriden by $USER if not specified
MACHUSER=${MACHUSER:=$USER}
inform "REMOTE USER:" "$MACHUSER"

# ensure WINDOWMANAGER arg has a value
WINDOWMANAGER=${WINDOWMANAGER:="mwm"}
if ! $(wm_check 2>&-) ; then
    die "INVALID WINDOWMANAGER: --wm $WINDOWMANAGER" "Valid values: $(echo ${WMS[@]})"
fi
inform "WINDOWMANAGER:" "$WINDOWMANAGER"

# set GEOMETRY TO false if not otherwise set
GEOMETRY=${GEOMETRY:="default"}
if [[ "$GEOMETRY" != default ]] && [[ ! "$GEOMETRY" =~ x ]] ; then
    usage
    die "--geometry should be expressed as two integers delimited by an \"x\""
fi 
inform "GEOMETRY:" "${GEOMETRY}" 

# set PIXELDEPTH TO 24 default if not overridden
PIXELDEPTH=${PIXELDEPTH:="24"}
inform "PIXELDEPTH:" "${PIXELDEPTH}"

# ensure we know what network requirements there are to connect to machine
NETWORK=$(check_network)
if [[ "${NETWORK}" =~ INVALID ]] ; then die "INVALID NETWORK" "CHECK $MACHINE" ; fi
inform "MACHINE:" "$MACHINE" 
inform "NETWORK:" "$NETWORK"

[[ "${SOURCE}x" != x ]] && inform "SOURCE:" "$SOURCE"
# setup initial ssh options for reuse
SSH_OPTS=$(setup_ssh_opts)
debug "SSH_OPTS:" "$SSH_OPTS"

# setup the appropriate ssh commands for the network
if [[ "${NETWORK}" =~ TURQUOISE ]] ; then
    GATEWAY="wtrw1.lanl.gov"
    GATEWAY_SSH=$(setup_gateway_ssh ${GATEWAY})
    GATEWAY_VNCPASSWD=$(setup_gateway_vncpasswd ${GATEWAY})
    CONTROL_CHECK=$(check_gateway_control_master_connection ${GATEWAY})
    CONTROL_KILL=$(kill_gateway_control_master_connection ${GATEWAY})
else
    NO_GATEWAY_SSH=$(setup_nogateway_ssh)
    NO_GATEWAY_VNCPASSWD=$(setup_nogateway_vncpasswd)
    CONTROL_CHECK=$(check_nogateway_control_master_connection)
    CONTROL_KILL=$(kill_nogateway_control_master_connection)
fi

debug "SSH CMD FOR ${NETWORK}:" "${GATEWAY_SSH}${NO_GATEWAY_SSH}"
debug "SSH CMD FOR VNCPW ${NETWORK}:" "${GATEWAY_VNCPASSWD}${NO_GATEWAY_VNCPASSWD}"

$(control_master_connection) || die "Control Master Connection Attempt Failed!"
$(${CONTROL_CHECK} &>/dev/null) || die "Control Master Check Failed!" 

# Ensure MACHINE is set to a real hostname, not round-robin
REAL_MACHINE=$(check_machine)
if [[ "${REAL_MACHINE}" =~ invalid ]] ; then die "INVALID MACHINE REQUEST" "$MACHINE" ; fi
if [[ "${MACHINE}" != "${REAL_MACHINE}" ]] ; then
    debug "MACHINE CHECK:" "$REAL_MACHINE NOT EQUAL TO $MACHINE, RESETTING CONTROL MASTER SSH CONNECTION"
    # setup the appropriate ssh commands for the network
    MACHINE="${REAL_MACHINE}"
    if [[ "${NETWORK}" =~ TURQUOISE ]] ; then
        GATEWAY="wtrw1.lanl.gov"
        GATEWAY_SSH=$(setup_gateway_ssh ${GATEWAY})
        GATEWAY_VNCPASSWD=$(setup_gateway_vncpasswd ${GATEWAY})
    else
        $(${CONTROL_KILL}) || die "Can't kill control socket"
        NO_GATEWAY_SSH=$(setup_nogateway_ssh)
        NO_GATEWAY_VNCPASSWD=$(setup_nogateway_vncpasswd)
        CONTROL_CHECK=$(check_nogateway_control_master_connection)
        CONTROL_KILL=$(kill_nogateway_control_master_connection)
        $(control_master_connection) || die "Control Master Reset Attempt Failed!"
        $(${CONTROL_CHECK} &>/dev/null) || die "Control Master Check Failed!" 
    fi
fi

debug "SSH CMD FOR ${NETWORK}:" "${GATEWAY_SSH}${NO_GATEWAY_SSH}"

# some client side logs, the second one is only in the event of a failure
LOGDIR="${HOME:=~}/.vnc2hpc/${MACHINE}"
mkdir -p "${LOGDIR}"
CLIENT_LOG_FILE="vncclient.log.${MYDATE}"
inform "VNC CLIENT ${CLIENT//*\//} LOGGING:" "${LOGDIR}/${CLIENT_LOG_FILE}"
SERVER_LOG_FILE="vncserver.log.${MYDATE}"
inform "VNC SERVER LOGGING:" "${LOGDIR}/${SERVER_LOG_FILE}"

# check the remote shell
REMOTE_SHELL=$(check_remote_shell)
debug "$MACHINE $MACHUSER SHELL:" "${REMOTE_SHELL}"

# check vncpasswd
check_vncpasswd

# sanity check Machine arg after running check_machine
if [[ "${MACHINE}"x == x ]] || [[ "${MACHINE}" =~ invalid ]] ; then
    usage
    die "PASS -m <frontend> TO ${0//\.\\/}!" "RECEIVED:${MACHINE}"
fi

# check remote vncserver install path
VNCSERVER_PATH=$(check_vncserver)
debug "$MACHINE VNCSERVER_PATH:" "${VNCSERVER_PATH}"

# check remote install path for vnc2hpc backend
check_remote_install_path || NO_BACKEND="true"

# setup NO_GATEWAY_SCP or GATEWAY_SCP commands to get server side setup
if [[ "${NO_BACKEND}" == "true" ]] ; then
    REPO_URL="https://git.lanl.gov/hpcsoft/vnc2hpc/-/archive/${VERSION}/vnc2hpc-${VERSION}.tar.gz"
    debug "REPO_URL:" "${REPO_URL}"
    FILE="${REPO_URL//*\/}"
    FULL_FILE_PATH="/tmp/${FILE}"
    debug "DOWNLOAD TO FILE:" "${FULL_FILE_PATH}"
    DEST="\$HOME/.vnc2hpc/."
    debug "COPYING ${FULL_FILE_PATH} TO:" "$DEST"
    export no_proxy=lanl.gov
    # get the repo locally
    if [[ "${SOURCE}x" != x ]] ; then
        FILE="${SOURCE//*\/}"
        FULL_FILE_PATH="{SOURCE}"
    else
        if $(which curl &>/dev/null) ; then
            debug "CURL CMD:" "curl -sL ${REPO_URL} &>${FULL_FILE_PATH}"
            curl -sL ${REPO_URL} >${FULL_FILE_PATH}
            if [[ $? -ne 0 ]] ; then 
                die "CURL CMD:" "curl -sL ${REPO_URL} &>${FULL_FILE_PATH} FAILED"
            fi
        elif $(which wget &>/dev/null); then
            debug "WGET CMD:" "wget ${REPO_URL} -O ${FULL_FILE_PATH}"
            wget ${REPO_URL} -O ${FULL_FILE_PATH}
            if [[ $? -ne 0 ]] ; then 
                die "WGET CMD:" "wget ${REPO_URL} -O ${FULL_FILE_PATH} FAILED"
            fi
        else
            die "EITHER INSTALL CURL OR WGET, or DOWNLOAD $REPO_URL AND POINT THIS TOOL TO THE TARBALL: $0 -s /path/to/tar.gz <etc>"
        fi
    fi
    [ -f ${FULL_FILE_PATH} ] || die "FAILURE DOWNLOADING ${REPO_URL} TO ${FULL_FILE_PATH}"
    DEST_TOPLEVEL_DIR=$(tar tf ${FULL_FILE_PATH} | head -n1 | sed 's/\///g')
    debug "DEST_TOPLEVEL_DIR:" "$DEST_TOPLEVEL_DIR"
    ${GATEWAY_SSH}${NO_GATEWAY_SSH} "mkdir -p ${DEST%\/\.}"
    if [[ $? -ne 0 ]] ; then
        die "$HOME/.vnc2hpc doesn't exist on $MACHINE"
    fi
    SSH_SCP_OPTS=$(setup_ssh_opts scp)
    if [[ "${NETWORK}" =~ TURQUOISE ]] ; then
        GATEWAY_SCP=$(setup_gateway_scp ${GATEWAY} ${FULL_FILE_PATH} ${DEST})
        if ! $GATEWAY_SCP &>/dev/null ; then
            die "SCP ${FULL_FILE_PATH} ${DEST} FAILED!"
        fi
    else
        NO_GATEWAY_SCP=$(setup_nogateway_scp ${FULL_FILE_PATH} ${DEST})
        if ! $NO_GATEWAY_SCP &>/dev/null ; then
            die "SCP ${FULL_FILE_PATH} ${DEST} FAILED!"
        fi 
    fi 
    if ! ${GATEWAY_SSH}${NO_GATEWAY_SSH} "pushd ${DEST} && tar xfz ${FILE}" &>/dev/null ; then
        die "FAILURE STAGING BACKEND SCRIPTS TO ${DEST}"
    else
        REMOTE_INSTALL_PATH="${DEST%\/\.}/${DEST_TOPLEVEL_DIR}"
        inform "BACKEND SCRIPTS STAGED TO:" "${DEST}"
        inform "RESETTING REMOTE_INSTALL_PATH:" "$REMOTE_INSTALL_PATH"
    fi
fi   
    
all_active_displays=( $(get_vnc_connections) )
debug "ALL USERS VNCSERVER DISPLAYS ON ${MACHINE}:" "$(echo ${all_active_displays[@]})"

# grab user specific vncserver from vncserver -list command on remote
active_displays=( $(list_displays) )
if [[ ${#active_displays[@]} -eq 0 ]] ; then
    debug "DETECT NO PREVIOUSLY RUNNING VNCSERVERS:" "${MACHUSER}@${MACHINE}"
else
    debug "DETECT ${#active_displays[@]} VNCSERVERS:" "${MACHUSER}@${MACHINE}" "${active_displays[@]}"
fi 

# test connecting to remote and scraping ps output for Xvnc
if [[ "${all_active_displays[@]}" =~ FAILURE ]] ; then
    die "DETECTED FAILURE WITH SSH TO: ${MACHINE}"
elif [[ ${#all_active_displays[@]} -eq 0 ]] ; then
    debug "NOT FINDING OTHER VNCSERVERS RUNNING ON" "${MACHINE}"
else
    debug "ALL USERS XVNC SESSIONS ON ${MACHINE}:" "$(echo ${all_active_displays[@]})"
fi

# test connecting to remote and scraping vncserver -list output for user specific displays
if [[ "${active_displays[@]}" =~ FAILURE ]] ; then
    die "FAILURE CONNECTING TO:" "${MACHINE}" "active_displays: ${active_displays[@]}"
elif [[ ${#active_displays[@]} -eq 0 ]] ; then
    debug "NOT FINDING OTHER XVNC SESSIONS RUNNING FOR $MACHUSER" "${MACHINE}"
else
    debug "XVNC SESSIONS ON ${MACHINE} FOR $MACHUSER" "$(echo ${active_displays[@]})"
fi

# attempt to reconnect to the first vncserver -list display available to $USER if port isn't specified
if [[ "${RECONNECT}"x != x ]] && [[ "${#active_displays[@]}" -gt 0 ]] ; then
    if [[ "${DISPLAY}"x == x ]] ; then
        # grab the first element in active_displays
        DISPLAY=${active_displays}
        inform "RECONNECT REQUESTED WITHOUT DISPLAY ARGUMENT. USING:" "${DISPLAY}"
    elif ! [[ "${active_displays[@]}" =~ $DISPLAY ]] ; then
        die "DISPLAY $DISPLAY NOT RUNNING VNCSERVER DISPLAY FOR" "$MACHUSER on ${MACHINE}"
    else
        inform "ATTEMPTING CONNECTION TO REQUESTED DISPLAY" "localhost:$(( 5900+${DISPLAY} ))"
    fi
fi

# ensure that we limit displays to one per user per host, if there are more than one vncservers running for $MACHUSER, force a kill, exit, or reuse of that server
if [[ "${#active_displays[@]}" -ge 1 ]] && [[ $RECONNECT != "true" ]] && [[ $BACKDOOR != "true" ]] ; then
    warning "ACTIVE VNCSERVER DISPLAYS FOR $MACHUSER ON ${MACHINE}" "$(echo "${active_displays[@]}")"
    warning "DO YOU WISH TO KILL OR REUSE THIS SESSION?" "[Y - yes (kill it), N - exit (keep it, exit), R - reuse]?"
    read RESPONSE
    case $RESPONSE in
        Y*|y*)
	    for p in ${active_displays[@]} ; do
                output=$(kill_vnc $p)
                # need to regenerate this list after killing $p
                active_displays=( $(list_displays) )
	        warning "$output"
            done
	;;
        N*|n*)
	    warning "YOU HAVE ${#active_displays[@]} VNCSERVER SESSIONS RUNNING!"
	    warning "YOUR LISTENING VNC SESSIONS ARE RUNNING ON" "$(for p in ${active_displays[@]}; do printf "%s " $p ; done)"
	    die "YOU MUST KILL SOME SESSIONS OR SPECIFY" "${0} \"-p \$DISPLAY\""
	;;
        R*|r*)
	    debug "WILL REUSE DISPLAY ${active_displays}"
            debug "WILL ALSO KEEP DISPLAY ACTIVE UPON DISCONNECT"
	    KEEP_VNC_SERVER_ACTIVE=true
            DISPLAY=${active_displays}
	;;
    esac
fi

# generate a random display number
if [[ "${DISPLAY}"x == x ]] ; then
    DISPLAY=0
    FLOOR=11111
    RANGE=$(( 65535-5900 ))
    while ! [[ ${all_active_displays[@]} =~ '${DISPLAY}' ]] && ( [ "$DISPLAY" -le $FLOOR ] || [ "$DISPLAY" -gt $RANGE ] ) ; do
        DISPLAY=$RANDOM
    done
fi

# manage some details on the formats
if [[ ${#DISPLAY} -lt 2 ]] && [[ -n ${DISPLAY} ]]; then
    DISPLAY=0${DISPLAY}
else
    DISPLAY=${DISPLAY}
fi

# strip leading zeros from lower-case port
DISPLAY=${DISPLAY#0}

# test local tunnel connections for conflicts
until ! lsof -i -n |grep "127.0.0.1:$(( ${DISPLAY}+5900 ))" &>/dev/null ; do
    TUNNEL_CONFLICT=$(lsof -i -n |grep "127.0.0.1:$(( ${DISPLAY}+5900 ))")
    debug "DETECTED TUNNEL CONFLICT:" "${TUNNEL_CONFLICT}"
    # Increment $DISPLAY to avoid conflict
    DISPLAY=$(( $DISPLAY+1 ))
    DISPLAY=${DISPLAY}
    inform "TUNNEL CONFLICT:" "${TUNNEL_CONFLICT}"
    inform "NEW DISPLAY:" "${DISPLAY}"
done

# if the display requested isn't already actively listening for USER, call startvncserver script remotely
if ! [[ "${active_displays[@]}" =~ $DISPLAY ]] ; then
    debug "RUNNING:" "${GATEWAY_SSH}${NO_GATEWAY_SSH} \"${REMOTE_INSTALL_PATH}/bin/start_vncserver.sh \
           \"${VERSION}\" \"${WINDOWMANAGER}\" \"${CLIENT_VERSION}\" \"${CLIENTOS}\" \"${GEOMETRY}\" \"${PIXELDEPTH}\" \"${REMOTE_INSTALL_PATH}\" \"${VNCSERVER_PATH}\" \"${DISPLAY}\"\""
    newport=$(${GATEWAY_SSH} ${NO_GATEWAY_SSH} "${REMOTE_INSTALL_PATH}/bin/start_vncserver.sh \
           \"${VERSION}\" \"${WINDOWMANAGER}\" \"${CLIENT_VERSION}\" \"${CLIENTOS}\" \"${GEOMETRY}\" \"${PIXELDEPTH}\" \"${REMOTE_INSTALL_PATH}\" \"${VNCSERVER_PATH}\" \"${DISPLAY}\"")
    # turquoise network connection requires parsing weird carriage return characters
    newport=${newport%$'\r'}
    if [[ "${newport}" =~ FAIL ]] || [[ "${newport}" == "0" ]] || [[ -z "${newport}" ]] ; then
        die "start_vncserver.sh returns:" "$(echo $newport)"
    else
        # reassign port here to the actual port vncserver established
        DISPLAY="${newport}"
        # strip leading zeros from lower-case port
        DISPLAY=${DISPLAY#0}
        # zero pad single digit displays this still is needed in case a vncserver autoselects low display number
        if [ ${#DISPLAY} -lt 2 ] ; then
           DISPLAY=0${DISPLAY}
        else
           DISPLAY=${DISPLAY}
        fi
        debug "DISPLAY NUMBER ADJUSTED FOR ZERO PADDING" "$DISPLAY"
        debug "DISPLAY NUMBER ADJUSTED TO REMOVE ZEROS" "$DISPLAY"
    fi
    sleep 2.5
else
    debug "VNCSERVER RUNNING AS $USER ALREADY on $DISPLAY" "WILL USE THIS DISPLAY $DISPLAY"
fi

# get tunnel string
TUNNEL_HOST=$(setup_tunnel_host)

# need the tunnel to include the display as determined above
if [[ "${NETWORK}" =~ TURQUOISE ]] ; then
    GATEWAY="wtrw1.lanl.gov"
    GATEWAY_TUNNEL=$(setup_gateway_tunnel ${GATEWAY})
else
    NO_GATEWAY_TUNNEL=$(setup_nogateway_tunnel)
fi

debug "TUNNEL FOR ${NETWORK}:" "${NO_GATEWAY_TUNNEL} ${GATEWAY_TUNNEL}"

# generic tunnel invocation
debug "RUNNING:" "${GATEWAY_TUNNEL}${NO_GATEWAY_TUNNEL} sleep 25 &>/dev/null &"
${GATEWAY_TUNNEL} ${NO_GATEWAY_TUNNEL} &>/dev/null &
tunnel_pid=$!

# establish a ssh local tunnel to $MACHINE
debug "STARTING PORT FORWARDING" "`hostname -s` TO ${MACHINE} ON PORT $(( 5900+$DISPLAY ))"
debug "TUNNEL PID IS:" "${tunnel_pid}"

# test that the Xvnc process on $DISPLAY was instantiated
remote_pid=$( ${GATEWAY_SSH} ${NO_GATEWAY_SSH} "ps aux" 2>&- \
              | awk -v exclude="awk" -v pat="Xvnc :*$DISPLAY " '($0 !~ exclude) && $0~pat{print $2}' )
debug "XVNC PID IS:" "${remote_pid}"

# fail if not
if [[ "${remote_pid}x" == x ]] ; then
    die "ERROR OCCURRED STARTING VNCSERVER."
fi

inform "CONNECTING $CLIENT_VERSION TO:" "$MACHINE:$(( 5900+$DISPLAY))" 
inform "WHILE RUNNING:" "KEEP THIS TERMINAL ACTIVE!" 
inform "TO TERMINATE:" "CLOSE $CLIENT_VERSION WINDOW"

# connect client to localhost
if [[ "${CLIENT_VERSION}" =~ [Tt]iger ]] ; then
    warning "Client: ${CLIENT}" "Redirecting ${CLIENT} stdout to ${LOGDIR}/${CLIENT_LOG_FILE}"
    "$CLIENT" localhost::$(( 5900+${DISPLAY} ))>> ${LOGDIR}/${CLIENT_LOG_FILE} 2>&1
else
    "$CLIENT" localhost::$(( 5900+${DISPLAY} )) -EnableUdpRfb=false -WarnUnencrypted=0 -SecurityNotificationTimeout=0 -LogDir=${LOGDIR} -LogFile=${CLIENT_LOG_FILE}
fi

# test client connection return code
if [[ $? -ne 0 ]] ; then
    message -r "FAILURE CONNECTING $CLIENT TO $DISPLAY"
fi

# if -k is passed to the script, don't kill the process
if [[ "${KEEP_VNC_SERVER_ACTIVE}"x != x ]]; then
    inform "KEEPING VNC SERVER RUNNING ON:" "${MACHINE} AT DISPLAY $DISPLAY Active"
else
    inform "KILLING VNC SERVER RUNNING ON:" "${MACHINE} AT DISPLAY $DISPLAY"
    kill_vnc_output=$(kill_vnc $DISPLAY)
    debug "OUTPUT FROM KILL VNC:" "${kill_vnc_output[@]}"
fi

# killing the tunnel to $MACHINE
if kill -0 ${tunnel_pid} &>/dev/null ; then
    kill ${tunnel_pid} &>/dev/null
fi

remotelog
$(${CONTROL_KILL})

exit

#!/bin/bash
#
# vnc2hpc is a script that automates establishing vncclient>server connections to LANL HPC systems

# Basic VNC2HPC information
AUTHOR_EMAIL="jgreen@lanl.gov"
CONTACT="vnc2hpc@lanl.gov"
REPO="git@git.lanl.gov:hpcsoft/vnc2hpc.git"
README="https://git.lanl.gov/hpcsoft/vnc2hpc/-/blob/master/README.md"

# Timestamp string for logs
MYDATE=$(date +%m-%d-%y"-"%H.%M.%S)

# SSH Control Master Socket
SSH_SOCKET="~/.ssh/connections/%C"

# Versioning approach
# Feature updates signified by even numbers
# Bugfix updates signified by odd numbers
VERSION="0.0.5"
REMOTE_INSTALL_PATH="/usr/projects/hpcsoft/vnc2hpc/${VERSION}"

# Window managers supported:
WMS=( "berry" "icewm" "fvwm" "mwm" "openbox" "xfwm4" )

usage () {
    message -m "${0//*\//} v${VERSION}

          usage: ${0//*\//}
                            [-m|--machine <machine>]				(required)
                            [-c|--client <vncclient>]				(required)
			    [-u|--user <hpcuserid>] 				(optional) Default: \$USER on localhost 
                            [-d|--debug]					(optional)
	                    [-p|--port <display port>]				(optional)
			    [-k|--keep]						(optional)
			    [-r|--reconnect]					(optional)
			    [-w|--wm <icewm|berry|fvwm|mwm|xfwm4|openbox>]	(optional) Default: [-w mwm] (Motif Window Manager)
                            [-g|--geometry <int>x<int>]                 	(optional) Default: xdpyinfo |grep dimensions
                            [-P|--pixeldepth <int>]                     	(optional) Default: 24 - others: 8, 15, 16
			    [-h|--help]

          Questions?        <${CONTACT}>
          Need Help?        ${README}
"
}

#######################################
# Identify the Network for $MACHINE
# Globals:
#   MACHINE
# Arguments:
#   None
# Outputs:
#   Writes $loc_network to stdout
#######################################
check_network () {
    local loc_network
    case "${MACHINE}" in
        *loginy*|*fey*)        loc_network="YELLOW"        ;;
        ic*|fi*|cy*|tr*|vm*)   loc_network="RED"           ;;
        wtrw*)                 loc_network="invalid"       ;;
	*)                     loc_network="TURQUOISE"     ;;
    esac
    echo "${loc_network}"
}

#######################################
# Ensure $MACHINE resolves
# Globals:
#   MACHINE
#   NETWORK
#   GATEWAY_SSH
#   NO_GATEWAY_SSH
# Arguments:
#   None
# Outputs:
#   Writes $loc_machine to stdout
#######################################
check_machine () {
    local loc_machine
    local loc_machines
    local loc_machine_index
    if [[ "${MACHINE}"x != x ]] ; then
        if ! [[ "$MACHINE" =~ [0-9] ]] && ! [[ "${MACHINE}" =~ cp ]] && ! [[ "${MACHINE}" =~ th ]]  ; then
            case "${NETWORK}" in
                YELLOW)    netpart="128.165" ;;
                TURQUOISE) netpart="204.121" ;;
                RED)       netpart="10.160"  ;;
            esac
            loc_machines=( $( ${GATEWAY_SSH} ${NO_GATEWAY_SSH} \
                "awk -v pat=\"^${netpart//\./\\\.}.*${MACHINE}.*gov\" '\$0~pat{print \$2}' /etc/hosts" 2>&- ) )
            if [[ ${#loc_machines[@]} -gt 0 ]] ; then
                loc_machine_index=$(( $RANDOM % ${#loc_machines[@]} ))
                loc_machine="${loc_machines[$loc_machine_index]}"
            else
            # try to access "${MACHINE}1" before failing
                loc_machine="${MACHINE}1"
            fi
        elif [[ "${MACHINE}" =~ wtrw ]] ; then
            loc_machine="invalid"
        else
            loc_machine="${MACHINE}"
        fi
    else
        loc_machine="invalid"
    fi
    echo "$loc_machine"
}

#######################################
# Setup ssh options
# Globals:
#   SSH_SOCKET
# Arguments:
#   None
# Outputs:
#   Writes $loc_ssh_opts to stdout
#######################################
setup_ssh_opts () {
    mkdir -p ~/.ssh/connections
    local loc_ssh_opts=""
    loc_ssh_opts+="-x"
    loc_ssh_opts+=" -tt"
    loc_ssh_opts+=" -N"
    loc_ssh_opts+=" -f"
    loc_ssh_opts+=" -o LogLevel=QUIET"
    loc_ssh_opts+=" -o GSSAPIDelegateCredentials=yes"
    loc_ssh_opts+=" -o StrictHostKeyChecking=no"
    loc_ssh_opts+=" -o ControlPath=${SSH_SOCKET}"
    echo "$loc_ssh_opts"
}

#######################################
# Setup ssh options for control master
# Globals:
#   SSH_SOCKET
# Arguments:
#   None
# Outputs:
#   Writes $loc_ssh_opts to stdout
#######################################
setup_ssh_master_opts () {
    mkdir -p ~/.ssh/connections
    local loc_ssh_opts=""
    loc_ssh_opts+="-M"
    loc_ssh_opts+=" -x"
    loc_ssh_opts+=" -N"
    loc_ssh_opts+=" -f"
    loc_ssh_opts+=" -o LogLevel=QUIET"
    loc_ssh_opts+=" -o GSSAPIDelegateCredentials=yes"
    loc_ssh_opts+=" -o StrictHostKeyChecking=no"
    loc_ssh_opts+=" -o ControlPersist=yes"
    loc_ssh_opts+=" -o ControlPath=${SSH_SOCKET}"
    echo "$loc_ssh_opts"
}

#######################################
# Setup port/host string for tunnels
# Globals:
#   MACHINE
#   MACHUSER
#   PORT
# Arguments:
#   None
# Outputs:
#   Writes $TUNNELHOST to stdout
#######################################
setup_tunnel_host () {
    echo "-L 59${PORT}:localhost:59${PORT}"
}

#######################################
# Ssh command
# Globals:
#   SSH_OPTS
#   MACHUSER
#   MACHINE
# Arguments:
#   None
# Outputs:
#   Writes ssh cmd to stdout
#######################################
setup_nogateway_ssh () {
    echo "ssh ${SSH_OPTS} ${MACHUSER}@${MACHINE}"
}

#######################################
# Ssh command check control master
# Globals:
#   SSH_OPTS
#   MACHUSER
#   MACHINE
# Arguments:
#   None
# Outputs:
#   Writes ssh cmd to stdout
#######################################
check_nogateway_control_master_connection () {
    local loc_control_check="ssh -O check ${SSH_OPTS} ${MACHUSER}@${MACHINE}"
    echo "${loc_control_check}"
}

#######################################
# Ssh command kill control master
# Globals:
#   SSH_OPTS
#   MACHUSER
#   MACHINE
# Arguments:
#   None
# Outputs:
#   Writes ssh cmd to stdout
#######################################
kill_nogateway_control_master_connection () {
    local loc_control_kill="ssh -O exit ${SSH_OPTS} ${MACHUSER}@${MACHINE}"
    echo "${loc_control_kill}"
}

#######################################
# Ssh command via wtrw
# Globals:
#   SSH_OPTS
#   MACHUSER
#   MACHINE
# Arguments:
#   GATEWAY
# Outputs:
#   Writes ssh via wtrw to stdout
#######################################
setup_gateway_ssh () {
    local loc_gateway="$1"
    echo "ssh ${SSH_OPTS} ${MACHUSER}@${loc_gateway} ssh ${MACHUSER}@${MACHINE} "
}

#######################################
# Ssh command check gateway control master
# Globals:
#   SSH_OPTS
#   MACHUSER
#   MACHINE
# Arguments:
#   GATEWAY
# Outputs:
#   Writes ssh cmd to stdout
#######################################
check_gateway_control_master_connection () {
    local loc_gateway="$1"
    local loc_control_check="ssh -O check ${SSH_OPTS} ${MACHUSER}@${loc_gateway} ssh ${MACHUSER}@${MACHINE}"
    echo "${loc_control_check}"
}

#######################################
# Ssh command kill gateway control master
# Globals:
#   SSH_OPTS
#   MACHUSER
#   MACHINE
# Arguments:
#   GATEWAY
# Outputs:
#   Writes ssh cmd to stdout
#######################################
kill_gateway_control_master_connection () {
    local loc_gateway="$1"
    local loc_control_kill="ssh -O exit ${SSH_OPTS} ${MACHUSER}@${loc_gateway} ssh ${MACHUSER}@${MACHINE}"
    echo "${loc_control_kill}"
}

#######################################
# Tunnel to host
# Globals:
#   SSH_OPTS
#   PORT
#   MACHUSER
#   MACHINE
#   TUNNEL_HOST
# Arguments:
#   None
# Outputs:
#   Writes ssh tunnel cmd to stdout
#######################################
setup_nogateway_tunnel () {
    echo "ssh ${SSH_OPTS} ${TUNNEL_HOST} ${MACHUSER}@${MACHINE}"
}

#######################################
# Tunnel to host via gateway
# Globals:
#   PORT
#   MACHUSER
#   MACHINE
#   SSH_OPTS
#   TUNNEL_HOST
# Arguments:
#   GATEWAY
# Outputs:
#   Writes ssh tunnel cmd to stdout
#######################################
setup_gateway_tunnel () {
    local loc_gateway="$1"
    echo "ssh ${SSH_OPTS} ${TUNNEL_HOST} ${MACHUSER}@${loc_gateway} ssh -tt ${TUNNEL_HOST} ${MACHUSER}@${MACHINE}"
}

#######################################
# Colorize output
# Globals:
#   None
# Arguments:
#   opt
#   $[1-4]
# Outputs:
#   colorizes message output based on flag
#######################################
message () {
    local color
    local OPTIND
    local opt
    while getopts "crgymn" opt; do
        case $opt in
            c)  color=$(tput setaf 6) ;;
            r)  color=$(tput setaf 1) ;;
	    g)  color=$(tput setaf 2) ;;
	    y)  color=$(tput setaf 3) ;;
	    m)  color=$(tput setaf 5) ;;
            *)  color=$(tput sgr0)    ;;
        esac
    done
    shift $(($OPTIND -1))
    printf "${color}%-10s %-50s %-50s %-50s\n" "$1" "$2" "$3" "$4"
    tput sgr0
}

#######################################
# Warn if something's amiss
# Globals:
#   None
# Arguments:
#   $[1-3]
# Outputs:
#   yellow printf output
#######################################
warning () {
    message -y "NOTE" "$1" "$2" "$3"
}

#######################################
# Gracefully exit on error
# Globals:
#   tunnel_pid
# Arguments:
#   $[1-3]
# Outputs:
#   red printf output
#######################################
die () {
    remotelog
    if kill -0 ${tunnel_pid} &>/dev/null ; then
        kill ${tunnel_pid} &>/dev/null
    fi
    $(${CONTROL_KILL})
    message -r "ERROR" "$1" "$2" "$3" >&2
    exit 2
}

#######################################
# Informative messages to user
# Globals:
#   None
# Arguments:
#   $[1-3]
# Outputs:
#   green printf output
#######################################
inform () {
    message -g "INFO" "$1" "$2" "$3"
}

#######################################
# Informative messages to user
# Globals:
#   None
# Arguments:
#   $[1-3]
# Outputs:
#   cyan printf output
#######################################
debug () {
    if [[ "${DEBUG}"x != x ]] ; then
        message -c "DEBUG" "$1" "$2" "$3"
    fi
}

#######################################
# Establish ControlMaster ssh connection
# Globals:
#   GATEWAY_SSH
#   NO_GATEWAY_SSH
# Arguments:
#   None
# Outputs:
#   control_master_ssh
#######################################
control_master_connection () {
    SSH_OPTS=$(setup_ssh_master_opts)
    if [[ "${NETWORK}" =~ TURQUOISE ]] ; then
        local local_gateway="wtrw1.lanl.gov"
        local local_gateway_ssh=$(setup_gateway_ssh ${local_gateway})
    else
        local local_nogateway_ssh=$(setup_nogateway_ssh)
    fi
    local local_control_master_ssh="${local_gateway_ssh} ${local_nogateway_ssh}"
    echo "${local_control_master_ssh}"
}

#######################################
# Checks/sets vncpasswd interactively
# Globals:
#   GATEWAY_SSH
#   NO_GATEWAY_SSH
#   MACHUSER
#   MACHINE
# Arguments:
#   None
# Outputs:
#   None
#######################################
checkvncpasswd () {
    # need a $HOME/.vnc directory if the first use
    if ! $( ${GATEWAY_SSH} ${NO_GATEWAY_SSH} "[ -d \$HOME/.vnc ]" 2>&- ); then
        ${GATEWAY_SSH} ${NO_GATEWAY_SSH} "mkdir -p \$HOME/.vnc && chmod -Rf 0700 \$HOME/.vnc &>/dev/null" 2>&-
    fi
    # test whether the vncpasswd file exists but is empty
    if ! $( ${GATEWAY_SSH} ${NO_GATEWAY_SSH} "[ -s  \$HOME/.vnc/passwd ]" 2>&- ); then

        # ensure user is forewarned of potential exposure of passwd with xtrace
        if echo ${SHELLOPTS} | grep xtrace &>/dev/null ; then
            DISABLE_XTRACE="set +x"
            ENABLE_XTRACE="set -x"
        fi
        #${DISABLE_XTRACE}

        inform "VNC passwd not available or is of zero size on ${MACHINE} for $MACHUSER"
        inform "Do you want to setup a password now? [Y/N]"
        read PWREPLY

        case $PWREPLY in
            Y*|y*)
                inform "Enter your password (at least six characters long, up to eight)"
                read -s VNCPW
                inform "Reenter your password to confirm"
                read -s REVNCPW
                if [[ "${VNCPW}" == "${REVNCPW}" ]] ; then
                    inform "SETTING VNCPASSWD" "${MACHINE} for $MACHUSER"
                    eval 'ssh sn-fey2 <<EOF
echo ${VNCPW} | /usr/bin/vncpasswd -f > \$HOME/.vnc/passwd && chmod 0600 \$HOME/.vnc/passwd
EOF'
#                    sleep 5
#                    if [[ $? -ne 0 ]] ; then
#                        die "SOMETHING WENT WRONG SETTING YOUR VNCPASSWD"
#                    elif ! $( ${GATEWAY_SSH} ${NO_GATEWAY_SSH} "[ -f \$HOME/.vnc/passwd ]" ); then
#                        die "SOMETHING WENT WRONG SETTING YOUR VNCPASSWD"
#                    else
#                        inform "VNCPASSWD SET!"
#                    fi
                else
                    die "FIRST AND SECOND PASSWORDS DIDN'T MATCH"
                fi
                perms=$(${GATEWAY_SSH} ${NO_GATEWAY_SSH} "ls -alhs \$HOME/.vnc/passwd")
                debug "CHECKING PERMS ON PASSWD FILE:" "$perms"
            ;;
            N*|n*)
                die "YOU MUST LOGIN TO ${MACHINE} AND SETUP A VNC PASSWORD TO PROCEED"
            ;;
            *)
                die "A password to use your vncserver on ${MACHINE} is required!"
            ;;
        esac
        ${ENABLE_XTRACE}
    fi
}

#######################################
# Command to kill the vncserver
# Globals:
#   GATEWAY_SSH
#   NO_GATEWAY_SSH
#   MACHUSER
#   MACHINE
#   PORT
# Arguments:
#   LOCAL_PORT
# Outputs:
#   echos stdout from vncserver
#######################################
kill_vnc () {
    LOCAL_PORT=$1
    kill_vnc_response=$(${GATEWAY_SSH} ${NO_GATEWAY_SSH} vncserver -kill :${LOCAL_PORT} 2>&1)
    # strange characters in stdout via wtrw filtered in the substitution below
    echo "${kill_vnc_response%$'\r'}"
}

#######################################
# Command to get all users Xvnc instances on remote
# Globals:
#   GATEWAY_SSH
#   NO_GATEWAY_SSH
#   MACHUSER
#   MACHINE
# Arguments:
#   None
# Outputs:
#   ${LOCAL_VNC_CONS[@]}
#######################################
get_vnc_connections () {
    for pt in $( ${GATEWAY_SSH} ${NO_GATEWAY_SSH} "ps ax| grep -E \"/usr/bin/Xvnc :([0-9]+)\" \
                                                   | awk '{ gsub(\":\",\"\",\$6) } {print \$6}'") ; do
       LOCAL_VNC_CONS=( $(printf "%s " "${pt%$'\r'}") "${LOCAL_VNC_CONS[@]}" )
    done
    echo "${LOCAL_VNC_CONS[@]}"
}

#######################################
# Command to get Users Vncserver list
# Globals:
#   GATEWAY_SSH
#   NO_GATEWAY_SSH
#   MACHUSER
#   MACHINE
# Arguments:
#   None
# Outputs:
#   ${VNCSERVERS_LIST[@]}
#######################################
list_vncservers () {
    vncservers_list=( $(${GATEWAY_SSH} ${NO_GATEWAY_SSH} "vncserver -list|egrep -v 'DISPLAY|TigerVNC|^$' \
                                                          | awk '{ gsub(\":\",\"\",\$1); print \$1}'") )
    for item in ${vncservers_list[@]} ; do
        VNCSERVERS_LIST=( $(printf "%s " "${item%$'\r'}") "${VNCSERVERS_LIST[@]}" )
    done
    echo "${VNCSERVERS_LIST[@]}"
}

#######################################
# File tests ${client} for viability
# Globals:
#   client
# Arguments:
#   None
# Outputs:
#   None
#######################################
client_check () {
    ( [ ! -d "${client}" ] && [ -x "${client}" ] ) || [ -x "$(which ${client})" ] || exit 1
}

#######################################
# File tests ${WINDOWMANAGER} for viability
# Globals:
#   client
# Arguments:
#   None
# Outputs:
#   None
#######################################
wm_check () {
    if [[ ! "${WMS[@]}" =~ $WINDOWMANAGER ]] ; then
        return 2
    fi
}

#######################################
# Parses ${client} and version string
# Globals:
#   client
# Arguments:
#   None
# Outputs:
#   Client/Version
#######################################
client_version () {
    "${client}" -help 2>&1 | head -n 2 | awk '/./ {print $1$2"-"$3}' |head -n 1
}

#######################################
# Gets OS info on localhost
# Globals:
#   None
# Arguments:
#   None
# Outputs:
#   OS String
#######################################
clientOS () {
    uname -a | awk '{print $2"-"$1}'
}

#######################################
# Remote ssh to capture server log file
# Globals:
#   GATEWAY_SSH
#   NO_GATEWAY_SSH
#   MACHUSER
#   MACHINE
#   PORT
#   LOGDIR
#   SERVER_LOG_FILE
# Arguments:
#   None
# Outputs:
#   None
#######################################
remotelog () {
    if [[ -n ${GATEWAY_SSH} ]] || [[ -n ${NO_GATEWAY_SSH} ]] ; then 
       ${GATEWAY_SSH} ${NO_GATEWAY_SSH} "cat ~/.vnc/${MACHINE//\.*/}*\:*${PORT#0}.log 2>&-" >>${LOGDIR}/${SERVER_LOG_FILE}
    fi 
}

#######################################
# Parse positional parameters passed to script
echo "${@}" # REMOVE
for arg in "$@"; do
    shift
    case "$arg" in
        *-cl*nt)       set -- "$@" "-c"   ;;
        *-debug)       set -- "$@" "-d"   ;;
        *-help)        set -- "$@" "-h"   ;;
        *-keep)        set -- "$@" "-k"   ;;
        *-machine)     set -- "$@" "-m"   ;;
        *-port)        set -- "$@" "-p"   ;;
        *-reconnect)   set -- "$@" "-r"   ;;
        *-user)        set -- "$@" "-u"   ;;
        *-wm*)         set -- "$@" "-w"   ;;
        *-geo*)        set -- "$@" "-g"   ;;
        *-depth*)      set -- "$@" "-P"   ;;
        *)             set -- "$@" "$arg" ;;
    esac
done

OPTIND=1

while getopts "bc:m:P:p:u:w:g:dhrk-" opt ; do
    case "${opt}" in
        b)  BACKDOOR=true                                                                          ;;
        d)  DEBUG=true                                                                             ;;
        p)  port="$OPTARG"  ; debug "RECEIVED REQUEST TO CONNECT TO:" "${MACHINE} at port $port"   ;;
        m)  MACHINE="$OPTARG" ; debug "RECEIVED REQUEST TO CONNECT TO:" "${MACHINE}"               ;;
        c)  client=${OPTARG//\\/} && client=${client//\~/$HOME}                                    ;;
        k)  KEEP_VNC_SERVER_ACTIVE=true                                                            ;;
        r)  RECONNECT=true && KEEP_VNC_SERVER_ACTIVE=true                                          ;;
        h)  usage && exit 0                                                                        ;;
        u)  MACHUSER="${OPTARG}"                                                                   ;;
        w)  WINDOWMANAGER="${OPTARG}"                                                              ;;
        g)  GEOMETRY="${OPTARG}"                                                                   ;;
        P)  PIXELDEPTH="${OPTARG}"                                                                 ;;
        -)  continue                                                                               ;;
    esac
done

#######################################
# Inform vnc2hpc version used
inform "VNC2HPC INFO:" "Version v${VERSION}" 

# Check out the vncclient
if [[ "${client}x" == x ]] ; then usage; die "A PATH TO A VNC CLIENT MUST BE SUPPLIED TO ${0/\*/}!" ; fi
if ! $(client_check 2>&-) ; then die "$client" "FAILED BASIC TESTS" "RECHECK YOUR PATH TO VNCVIEWER" ; fi
CLIENT_VERSION=$(client_version)
inform "VNC CLIENT INFO:" "$CLIENT_VERSION"

# uname output on local host
CLIENTOS=$(clientOS)
inform "LOCALHOST OS INFO:" "$CLIENTOS"

# ensure MACHUSER is overriden by $USER if not specified
MACHUSER=${MACHUSER:=$USER}
inform "REMOTE USER:" "$MACHUSER"

# ensure WINDOWMANAGER arg has a value
WINDOWMANAGER=${WINDOWMANAGER:="mwm"}
if ! $(wm_check 2>&-) ; then
    die "INVALID WINDOWMANAGER: --wm $WINDOWMANAGER" "Valid values: $(echo ${WMS[@]})"
fi
inform "WINDOWMANAGER:" "$WINDOWMANAGER"

# set GEOMETRY TO false if not otherwise set
GEOMETRY=${GEOMETRY:="default"}
if [[ "$GEOMETRY" != default ]] && [[ ! "$GEOMETRY" =~ x ]] ; then
    usage
    die "--geometry should be expressed as two integers delimited by an \"x\""
fi 
inform "GEOMETRY:" "${GEOMETRY}" 

# set PIXELDEPTH TO 24 default if not overridden
PIXELDEPTH=${PIXELDEPTH:="24"}
inform "PIXELDEPTH:" "${PIXELDEPTH}"

# ensure we know what network requirements there are to connect to machine
NETWORK=$(check_network)
if [[ "${NETWORK}" =~ invalid ]] ; then die "INVALID NETWORK" "CHECK $MACHINE" ; fi
inform "MACHINE:" "$MACHINE" 
inform "NETWORK:" "$NETWORK"

# setup initial ssh options for reuse
SSH_OPTS=$(setup_ssh_opts)
debug "SSH_OPTS:" "$SSH_OPTS"

# setup the appropriate ssh commands for the network
if [[ "${NETWORK}" =~ TURQUOISE ]] ; then
    GATEWAY="wtrw1.lanl.gov"
    GATEWAY_SSH=$(setup_gateway_ssh ${GATEWAY})
    CONTROL_CHECK=$(check_gateway_control_master_connection ${GATEWAY})
    CONTROL_KILL=$(kill_gateway_control_master_connection ${GATEWAY})
else
    NO_GATEWAY_SSH=$(setup_nogateway_ssh)
    CONTROL_CHECK=$(check_nogateway_control_master_connection)
    CONTROL_KILL=$(kill_nogateway_control_master_connection)
fi
debug "SSH CMD FOR ${NETWORK}:" "${GATEWAY_SSH}${NO_GATEWAY_SSH}"

$(control_master_connection) || die "Control Master Connection Attempt Failed!"
$(${CONTROL_CHECK} &>/dev/null) || die "Control Master Check Failed!" 

# Ensure MACHINE is set to a real hostname, not round-robin
REAL_MACHINE=$(check_machine)
if [[ "${REAL_MACHINE}" =~ invalid ]] ; then die "INVALID MACHINE REQUEST" "$MACHINE" ; fi
if [[ "${MACHINE}" != "${REAL_MACHINE}" ]] ; then
    debug "MACHINE CHECK:" "$REAL_MACHINE NOT EQUAL TO" "$MACHINE"
    # setup the appropriate ssh commands for the network
    MACHINE="${REAL_MACHINE}"
    # setup ssh options for reuse
    SSH_OPTS=$(setup_ssh_opts)
    debug "SSH_OPTS:" "$SSH_OPTS"
    if [[ "${NETWORK}" =~ TURQUOISE ]] ; then
        GATEWAY="wtrw1.lanl.gov"
        GATEWAY_SSH=$(setup_gateway_ssh ${GATEWAY})
    else
        $(${CONTROL_KILL}) || die "Can't kill control socket"
        NO_GATEWAY_SSH=$(setup_nogateway_ssh)
        CONTROL_CHECK=$(check_nogateway_control_master_connection)
        CONTROL_KILL=$(kill_nogateway_control_master_connection)
        $(control_master_connection) || die "Control Master Reset Attempt Failed!"
        $(${CONTROL_CHECK} &>/dev/null) || die "Control Master Check Failed!" 
    fi
fi

debug "SSH CMD FOR ${NETWORK}:" "${GATEWAY_SSH}${NO_GATEWAY_SSH}"

if [[ "${MACHINE}"x == x ]] || [[ "${MACHINE}" =~ invalid ]] ; then
    usage
    die "PASS -m <frontend> TO ${0//\.\\/}!" "RECEIVED:${MACHINE}"
fi

# some client side logs, the second one is only in the event of a failure
LOGDIR="${HOME:=~}/.vnc2hpc/${MACHINE}"
mkdir -p "${LOGDIR}"
CLIENT_LOG_FILE="vncclient.log.${MYDATE}"
inform "VNC CLIENT ${client//*\//} LOGGING:" "${LOGDIR}/${CLIENT_LOG_FILE}"
SERVER_LOG_FILE="vncserver.log.${MYDATE}"
inform "VNC SERVER LOGGING:" "${LOGDIR}/${SERVER_LOG_FILE}"

# check vncpasswd
checkvncpasswd

# grab all Xvnc pid running, parse out the ports
all_active_vncserver_ports=( $(get_vnc_connections) )
debug "ALL USERS VNCSERVER PORTS ON ${MACHINE}:" "$(echo ${all_active_vncserver_ports[@]})"

# grab user specific vncserver from vncserver -list command on remote
active_vncserver_ports=( $(list_vncservers) )
if [[ ${#active_vncserver_ports[@]} -eq 0 ]] ; then
    debug "DETECT NO PREVIOUSLY RUNNING VNCSERVERS:" "${MACHUSER}@${MACHINE}"
else
    debug "DETECT ${#active_vncserver_ports[@]} VNCSERVERS:" "${MACHUSER}@${MACHINE}" "${active_vncserver_ports[@]}"
fi 

# test connecting to remote and scraping ps output for Xvnc
if [[ "${all_active_vncserver_ports[@]}" =~ FAILURE ]] ; then
    die "DETECTED FAILURE WITH SSH TO: ${MACHINE}"
elif [[ ${#all_active_vncserver_ports[@]} -eq 0 ]] ; then
    debug "NOT FINDING OTHER VNCSERVERS RUNNING ON" "${MACHINE}"
else
    debug "ALL USERS XVNC SESSIONS ON ${MACHINE}:" "$(echo ${all_active_vncserver_ports[@]})"
fi

# test connecting to remote and scraping vncserver -list output for user specific displays
if [[ "${active_vncserver_ports[@]}" =~ FAILURE ]] ; then
    die "FAILURE CONNECTING TO:" "${MACHINE}" "active_vncserver_ports: ${active_vncserver_ports[@]}"
else
    debug "XVNC SESSIONS ON ${MACHINE} FOR $MACHUSER" "$(echo ${active_vncserver_ports[@]})"
fi

# attempt to reconnect to the first vncserver -list display available to $USER if port isn't specified
if [[ "${RECONNECT}"x != x ]] ; then
    if [[ "${port}"x == x ]] ; then
        inform "RECONNECT REQUESTED WITHOUT PORT ARGUMENT"
	port=${active_vncserver_ports}
	inform "ATTEMPTING TO RECONNECT TO PORT ${port}"
    elif ! [[ "${active_vncserver_ports[@]}" =~ $port ]] ; then
        die "PORT $port NOT RUNNING VNCSERVER PORT FOR" "$MACHUSER on ${MACHINE}"
    else
        inform "ATTEMPTING CONNECTION TO REQUESTED PORT" "localhost:59$port"
    fi
fi

# ensure that we limit ports to one per user per host, if there are more than one vncservers running for $MACHUSER, force a kill, exit, or reuse of that server
if [[ "${#active_vncserver_ports[@]}" -ge 1 ]] && [[ $RECONNECT != "true" ]] && [[ $BACKDOOR != "true" ]] ; then
    warning "ACTIVE VNCSERVER PORTS FOR $MACHUSER ON ${MACHINE}" "$(echo "${active_vncserver_ports[@]}")"
    warning "DO YOU WISH TO KILL OR REUSE THIS SESSION?" "[Y - yes (kill it), N - exit (keep it, exit), R - reuse]?"
    read RESPONSE
    case $RESPONSE in
        Y*|y*)
	    for p in ${active_vncserver_ports[@]} ; do
                output=$(kill_vnc $p)
	        warning "$output"
            done
	;;
        N*|n*)
	    warning "YOU HAVE ${#active_vncserver_ports[@]} VNCSERVER SESSIONS RUNNING!"
	    warning "YOUR LISTENING VNC SESSIONS ARE RUNNING ON" "$(for p in ${active_vncserver_ports[@]}; do printf "%s " $p ; done)"
	    die "YOU MUST KILL SOME SESSIONS OR SPECIFY" "${0} \"-p \$port\""
	;;
        R*|r*)
	    debug "WILL REUSE PORT ${active_vncserver_ports}"
            debug "WILL ALSO KEEP PORT ACTIVE UPON DISCONNECT"
	    KEEP_VNC_SERVER_ACTIVE=true
            port=${active_vncserver_ports}
	;;
    esac
fi

# generate a random port number between 5901 5999
if [[ "${port}"x == x ]] ; then
    port=0
    FLOOR=2
    RANGE=99
    while ! [[ ${all_active_vncserver_ports[@]} =~ '${port}' ]] && ( [ "$port" -le $FLOOR ] || [ "$port" -gt $RANGE ] ) ; do
        port=$RANDOM
    done
fi

# manage some details on the port formats
if [[ ${#port} -lt 2 ]] && [[ -n ${port} ]]; then
    PORT=0${port}
else
    PORT=${port}
fi

# strip leading zeros from lower-case port
port=${port#0}

# if the port requested isn't already actively listening for USER, call startvncserver script remotely
if ! [[ "${active_vncserver_ports[@]}" =~ $port ]] ; then
    debug "RUNNING:" "${GATEWAY_SSH}${NO_GATEWAY_SSH} \"${REMOTE_INSTALL_PATH}/bin/start_vncserver.sh \
           \"${VERSION}\" \"${WINDOWMANAGER}\" \"${CLIENT_VERSION}\" \"${CLIENTOS}\" \"${GEOMETRY}\" \"${PIXELDEPTH}\" \"${PORT}\"\""
    newport=( $(${GATEWAY_SSH} ${NO_GATEWAY_SSH} "${REMOTE_INSTALL_PATH}/bin/start_vncserver.sh \
              \"${VERSION}\" \"${WINDOWMANAGER}\" \"${CLIENT_VERSION}\" \"${CLIENTOS}\" \"${GEOMETRY}\" \"${PIXELDEPTH}\" \"${PORT}\"" 2>&-) )
    # turquoise network connection requires parsing weird carriage return characters
    newport=${newport%$'\r'}
    if [[ "${newport}" =~ FAIL ]] || [[ "${newport}" == "0" ]] || [[ -z "${newport}" ]] ; then
        message -r "INVALID DISPLAY PORT" "DISPLAY PORT RETURNED BY ${REMOTE_INSTALL_PATH}/bin/start_vncserver.sh" "newport=$newport"
        die "STARTUP SCRIPT FOR VNCSERVER" "FAILED!"
    else
        # reassign port here to the actual port vncserver established
        port="${newport}"
        # strip leading zeros from lower-case port
        port=${port#0}
        # zero pad single digit ports this still is needed in case a vncserver autoselects low port number
        if [ ${#port} -lt 2 ] ; then
           PORT=0${port}
        else
           PORT=${port}
        fi
        debug "PORT NUMBER ADJUSTED FOR ZERO PADDING" "$PORT"
        debug "PORT NUMBER ADJUSTED TO REMOVE ZEROS" "$port"
    fi
    sleep 2.5
else
    debug "VNCSERVER RUNNING AS $USER ALREADY on $port" "WILL USE THIS PORT $port"
fi

# get tunnel string
TUNNEL_HOST=$(setup_tunnel_host)

# need the tunnel to include the port as determined above
if [[ "${NETWORK}" =~ TURQUOISE ]] ; then
    GATEWAY="wtrw1.lanl.gov"
    GATEWAY_TUNNEL=$(setup_gateway_tunnel ${GATEWAY})
else
    NO_GATEWAY_TUNNEL=$(setup_nogateway_tunnel)
fi
debug "TUNNEL FOR ${NETWORK}:" "${NO_GATEWAY_TUNNEL} ${GATEWAY_TUNNEL}"

# generic tunnel invocation
debug "RUNNING:" "${GATEWAY_TUNNEL}${NO_GATEWAY_TUNNEL} sleep 25 &>/dev/null &"
${GATEWAY_TUNNEL} ${NO_GATEWAY_TUNNEL} sleep 25 &>/dev/null &
tunnel_pid=$!

# establish a ssh local tunnel to $MACHINE
debug "STARTING PORT FORWARDING" "`hostname -s` TO ${MACHINE} ON PORT 59${PORT}"
debug "TUNNEL PID IS:" "${tunnel_pid}"

# test that the Xvnc process on $port was instantiated
remote_pid=$( ${GATEWAY_SSH} ${NO_GATEWAY_SSH} "ps aux" 2>&- \
              | awk -v exclude="awk" -v pat="Xvnc :*${PORT#0} " '($0 !~ exclude) && $0~pat{print $2}' )
debug "XVNC PID IS:" "${remote_pid}"

# fail if not
if [[ "${remote_pid}x" == x ]] ; then
    die "ERROR OCCURRED STARTING VNCSERVER."
fi

inform "CONNECTING $CLIENT_VERSION TO:" "$MACHINE:59$PORT" 
inform "WHILE RUNNING:" "KEEP THIS TERMINAL ACTIVE!" 
inform "TO TERMINATE:" "CLOSE $CLIENT_VERSION WINDOW"

# connect client to localhost
if [[ "${CLIENT_VERSION}" =~ [Tt]iger ]] ; then
    warning "Client: ${client}" "Redirecting ${client} stdout to ${LOGDIR}/${CLIENT_LOG_FILE}"
    "$client" localhost:59${PORT} >> ${LOGDIR}/${CLIENT_LOG_FILE} 2>&1
else
    "$client" localhost:59${PORT} -EnableUdpRfb=false -WarnUnencrypted=0 -SecurityNotificationTimeout=0 -LogDir=${LOGDIR} -LogFile=${CLIENT_LOG_FILE}
fi

# test client connection return code
if [[ $? -ne 0 ]] ; then
    message -r "FAILURE CONNECTING $client TO 59$PORT"
fi

# if -k is passed to the script, don't kill the process
if [[ "${KEEP_VNC_SERVER_ACTIVE}"x != x ]]; then
    inform "KEEPING VNC SERVER RUNNING ON:" "${MACHINE} AT DISPLAYPORT $port Active"
else
    inform "KILLING VNC SERVER RUNNING ON:" "${MACHINE} AT DISPLAYPORT $port"
    kill_vnc_output=$(kill_vnc $port)
    debug "OUTPUT FROM KILL VNC:" "${kill_vnc_output[@]}"
fi

# killing the tunnel to $MACHINE
if kill -0 ${tunnel_pid} &>/dev/null ; then
    kill ${tunnel_pid} &>/dev/null
fi

remotelog
$(${CONTROL_KILL})

exit
